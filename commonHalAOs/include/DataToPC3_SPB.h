//generated file: C:/AERTOSProjects/commonHalAOs\include\DataToPC3_SPB.h
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once


#include "AESPBObservorOutputType.h"
#include "AEUtils.h"
#include "FreeRTOS.h"
#include "AEFilter.h"

#include "AEIntegrationTesting.h"

//UserCode_Sectionheader

#include  "UploadDataToPcU.h"
//UserCode_Sectionheader_end

template<bool isSubscribable, uint32_t CHANNELCOUNTBUFFER1, uint32_t CHANNELCOUNTBUFFER2, uint32_t CHANNELCOUNTBUFFER3, TEMPLATESPB_Filters>
	class DataToPC3_SPB :
		public AESPBObservorOutputType <1, 3, isSubscribable,
TEMPLATESPB_FilterParams,
CHANNELCOUNTBUFFER1, false,
CHANNELCOUNTBUFFER2, false,
CHANNELCOUNTBUFFER3, false>
	{
	public:
		DataToPC3_SPB();
		
		//UserCode_Sectionpublic
//UserCode_Sectionpublic_end


	protected: UploadDataToPcU* uploadDataUToUse; 
public: UploadDataToPcU*  GetuploadDataUToUse()   const {return uploadDataUToUse; }


public: void UserInitialize(UploadDataToPcU* _uploadDataUToUse )
	{
		uploadDataUToUse =  _uploadDataUToUse;

		
		//UserCode_SectionuserInited
//UserCode_SectionuserInited_end
		
		userInitialized = true;
	}
private: bool userInitialized = false;
protected: void CheckIfConfiguredProperly() const override  
	{
		//DataToPC3_SPB::CheckIfConfiguredProperly();
		if (userInitialized == false)
		{
			// you did not initialize one of your AEobjects
			AEAssertRuntime(userInitialized == true, "user did not call the UserInitailize function for  DataToPC3_SPB"); 
		} 
		 
	}
	
	private:
	//UserCode_Sectionprivate
		float _AllDataToSend[CHANNELCOUNTBUFFER1 + CHANNELCOUNTBUFFER2 + CHANNELCOUNTBUFFER3];
//UserCode_Sectionprivate_end

		void RefreshOVERRIDE(float OutputSignal[1]) override;

	};


//UserCode_Sectionfunc
//UserCode_Sectionfunc_end


template<bool isSubscribable, uint32_t CHANNELCOUNTBUFFER1, uint32_t CHANNELCOUNTBUFFER2, uint32_t CHANNELCOUNTBUFFER3, TEMPLATESPB_FiltersFunctionParams>
	inline DataToPC3_SPB< isSubscribable,  CHANNELCOUNTBUFFER1,  CHANNELCOUNTBUFFER2,  CHANNELCOUNTBUFFER3, TEMPLATESPB_FilterParams>::DataToPC3_SPB()
	{
		//UserCode_Sectionctor
//UserCode_Sectionctor_end
	}

template<bool isSubscribable, uint32_t CHANNELCOUNTBUFFER1, uint32_t CHANNELCOUNTBUFFER2, uint32_t CHANNELCOUNTBUFFER3, TEMPLATESPB_FiltersFunctionParams>
	inline void DataToPC3_SPB< isSubscribable,  CHANNELCOUNTBUFFER1,  CHANNELCOUNTBUFFER2,  CHANNELCOUNTBUFFER3, TEMPLATESPB_FilterParams>::RefreshOVERRIDE(float OutputSignal[1])
	{

		float* ch1 = this->InputChannels[0]->ChannelSignalBufferSingle; 
float* ch2 = this->InputChannels[1]->ChannelSignalBufferSingle; 
float* ch3 = this->InputChannels[2]->ChannelSignalBufferSingle; 

 
		//UserCode_Sectionrefresh
		
		int totalSizeBytes = AEmemcpy_MultipleVariablesToArray<float>(_AllDataToSend, 
	ch1, CHANNELCOUNTBUFFER1,
	ch2, CHANNELCOUNTBUFFER2,
	ch3, CHANNELCOUNTBUFFER3
		);
		
		uploadDataUToUse->UploadDataToPC_WaitHereForFinish(this->GetAO_ID(), (char*)_AllDataToSend, totalSizeBytes);
		
		
//UserCode_Sectionrefresh_end
	}

