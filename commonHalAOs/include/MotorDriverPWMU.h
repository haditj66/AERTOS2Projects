//generated file: C:/AERTOSProjects/commonHalAOs\include\MotorDriverPWMU.h
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################


#pragma once

#include "AEUtilityAsService.h" 

#include "AEPublishSubscribeManager.h" 

#include "ActionRequestObjectArgTDU.h"
 
#include "AE_TDUAsService.h" 

#include "MotorDriverPWMU_ServiceGen.h"




//UserCode_Sectionheader
#include "AEPWM.h"
#include "AEGPIOOutput.h"
//UserCode_Sectionheader_end

class MotorDriverPWMU :   
	 public AEService< 10 , AENullActionRequest, AENullActionRequest, AENullActionRequest, ActionRequestObjectArgTDU1<float , bool, 10, MotorDriverPWMU>, AENullActionRequest, AENullActionRequest >
{
public: 

	//UserCode_Sectionpublic
//UserCode_Sectionpublic_end
	 
	MotorDriverPWMU ()
	{ 
		 //ActionReq1.ServiceName = "Transmit";
		
		
		ActionReq4.ServiceName = "RampUpToThisSpeed";
		
		 
		 
		MotorDriverPWMU_CTOR
		
		//UserCode_Sectionctor
//UserCode_Sectionctor_end
		 	
	}
	MotorDriverPWMU_Service
	
	
	protected: AEPWM* pwmPeripheral; 
public: AEPWM*  GetpwmPeripheral()   const {return pwmPeripheral; }
public:  void SetpwmPeripheral(AEPWM*  _pwmPeripheral){pwmPeripheral = _pwmPeripheral; }

protected: AEGPIOOutput* gpiotoChangeDirections; 
public: AEGPIOOutput*  GetgpiotoChangeDirections()   const {return gpiotoChangeDirections; }
public:  void SetgpiotoChangeDirections(AEGPIOOutput*  _gpiotoChangeDirections){gpiotoChangeDirections = _gpiotoChangeDirections; }

protected: float RampAcceleration; 
public: float  GetRampAcceleration()   const {return RampAcceleration; }
public:  void SetRampAcceleration(float  _RampAcceleration){RampAcceleration = _RampAcceleration; }


public: void UserInitialize(AEPWM* _pwmPeripheral , AEGPIOOutput* _gpiotoChangeDirections , float _RampAcceleration )
	{
		pwmPeripheral =  _pwmPeripheral;
gpiotoChangeDirections =  _gpiotoChangeDirections;
RampAcceleration =  _RampAcceleration;

		
		//UserCode_SectionuserInited
		pwmPeripheral->StartPWM(); 
		gpiotoChangeDirections = gpiotoChangeDirections; 
		gpiotoChangeDirections->GPIO_SetHigh();
//UserCode_SectionuserInited_end
		
		userInitialized = true;
	}
private: bool userInitialized = false;
protected: void CheckIfConfiguredProperly() const override  
	{
		//MotorDriverPWMU::CheckIfConfiguredProperly();
		if (userInitialized == false)
		{
			// you did not initialize one of your AEobjects
			AEAssertRuntime(userInitialized == true, "user did not call the UserInitailize function for  MotorDriverPWMU"); 
		} 
		 
	}
	
protected: 
	
	//UserCode_Sectionprot
	
	float DesiredSpeedToRampTo;
	float DeltaDutyPerUpdate;
	float CurrentSpeed;
	
	float GetCurrentSpeed()
	{
		CurrentSpeed = this->pwmPeripheral->GetDutyCycle();
		bool IsClockwise = this->gpiotoChangeDirections->GPIO_ReadPin();
		CurrentSpeed = IsClockwise == false ? CurrentSpeed * -1 : CurrentSpeed;
		return CurrentSpeed;

	}

	void UpdateDeltaDutyPerUpdate()
	{
		//update the currentspeed
		GetCurrentSpeed();

		float DeltaAbs = abs(RampAcceleration / this->FrequencyIUpdateAt);
		DeltaAbs = (abs((CurrentSpeed - DesiredSpeedToRampTo)) < DeltaAbs) ?
			abs((CurrentSpeed - DesiredSpeedToRampTo)) : DeltaAbs;



		if (CurrentSpeed < DesiredSpeedToRampTo)
		{
			DeltaDutyPerUpdate = DeltaAbs;
			return;
		}
		else if (CurrentSpeed > DesiredSpeedToRampTo)
		{
			DeltaDutyPerUpdate = DeltaAbs * -1;
			return;
		}
		else //CurrentSpeed == DesiredSpeedToRampTo
		{
			DeltaDutyPerUpdate = 0;
			return;
		}

	}

	void ChangeDutyCycle(float dutyCycleToChangeto)
	{

		if (dutyCycleToChangeto >= 0)
		{
			this->gpiotoChangeDirections->GPIO_SetHigh();
		}
		else
		{
			this->gpiotoChangeDirections->GPIO_SetLow();
		}
		this->pwmPeripheral->ChangeDutyCycle(abs(dutyCycleToChangeto));


	}
	
//UserCode_Sectionprot_end
	
	
	//example for waiting on an event
	//actReq->WaitForEvent<SomeOther_Sig>(
	//				[](void* s, AEEventDiscriminator_t* evt)->void {
	//					//SomeOther_Sig* sssc = (SomeOther_Sig*)evt->evt;
	//					AEPrint("Event SomeOther_Sig recieved"); 
	//					return;
	//				}
	//				, 500);
	
	//dont forget to return the service value when finished
	//actReq->SetReturnArg(1); 
	
	//return true in the update function for tdus when the service is done.
	
	//=====================================
	//Normal services
	//=====================================
	  
	  
	  
	
	
	//=====================================
	//TDU services
	//=====================================
	void _RampUpToThisSpeed(float speedToRampUpTo) 
   {

         //UserCode_SectionRampUpToThisSpeed
	   configASSERT(speedToRampUpTo >= -100);
	   configASSERT(speedToRampUpTo <= 100);
	   //if negative,  anticlockwise 
	   //set desired motor state.
	   DesiredSpeedToRampTo = speedToRampUpTo;

	   //get current motor speed
	   CurrentSpeed = GetCurrentSpeed();
//UserCode_SectionRampUpToThisSpeed_end 
   }

void _RampUpToThisSpeedCancelCleanup() 
   {

         //UserCode_SectionRampUpToThisSpeedcancel
	   DesiredSpeedToRampTo = CurrentSpeed;
//UserCode_SectionRampUpToThisSpeedcancel_end 
   }

    bool _RampUpToThisSpeedUpdate(ActionRequestObjectArgTDU1<float , bool, 10, MotorDriverPWMU>* request, float speedToRampUpTo) 
   {

         //UserCode_SectionRampUpToThisSpeedu
	   //update the current needed change in duty cycle
	   UpdateDeltaDutyPerUpdate();

	   //if it is zero then it must have reached its desired speed already
	   if (DeltaDutyPerUpdate == 0)
	   {
		   return 1;
	   }

	   //change it to this duty cycle
	   ChangeDutyCycle(DeltaDutyPerUpdate + CurrentSpeed);
	   return 0;
//UserCode_SectionRampUpToThisSpeedu_end 
    return true; 
    }
  
	  
	  
	 
	  

};




//UserCode_Sectionfunc
//UserCode_Sectionfunc_end