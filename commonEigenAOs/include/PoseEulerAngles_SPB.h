//generated file: C:/Users/hadi/Documents/AERTOSProjects/commonEigenAOs\include\PoseEulerAngles_SPB.h
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once


#include "AESPBObservorOutputType.h"
#include "AEUtils.h"
#include "FreeRTOS.h"
#include "AEFilter.h"

#include "AEIntegrationTesting.h"

//UserCode_Sectionheader

#include <Dense>
#include "ComplFilter.h"

//inptuts to the channels are
//accelx 
//accely  
//accelz 
//gyrox 
//gyroy 
//gyroz 
//magx
//magy
//magz

//UserCode_Sectionheader_end

template<bool isSubscribable, TEMPLATESPB_Filters>
	class PoseEulerAngles_SPB :
		public AESPBObservorOutputType <3, 9, isSubscribable,
TEMPLATESPB_FilterParams,
1, false,
1, false,
1, false,
1, false,
1, false,
1, false,
1, false,
1, false,
1, false>
	{
	public:
		PoseEulerAngles_SPB();
		
		//UserCode_Sectionpublic
//UserCode_Sectionpublic_end


	protected: ComplFilter* compFilt; 
public: ComplFilter*  GetcompFilt()   const {return compFilt; }


public: void UserInitialize(ComplFilter* _compFilt )
	{
		compFilt =  _compFilt;

		
		//UserCode_SectionuserInited
//UserCode_SectionuserInited_end
		
		userInitialized = true;
	}
private: bool userInitialized = false;
protected: void CheckIfConfiguredProperly() const override  
	{
		//PoseEulerAngles_SPB::CheckIfConfiguredProperly();
		if (userInitialized == false)
		{
			// you did not initialize one of your AEobjects
			AEAssertRuntime(userInitialized == true, "user did not call the UserInitailize function for  PoseEulerAngles_SPB"); 
		} 
		 
	}
	
	private:
	//UserCode_Sectionprivate
		int16_t const scale = 1000;
		double const pi = 3.14159265;
//UserCode_Sectionprivate_end

		void RefreshOVERRIDE(float OutputSignal[3]) override;

	};


//UserCode_Sectionfunc
//UserCode_Sectionfunc_end


template<bool isSubscribable, TEMPLATESPB_FiltersFunctionParams>
	inline PoseEulerAngles_SPB< isSubscribable, TEMPLATESPB_FilterParams>::PoseEulerAngles_SPB()
	{
		//UserCode_Sectionctor
//UserCode_Sectionctor_end
	}

template<bool isSubscribable, TEMPLATESPB_FiltersFunctionParams>
	inline void PoseEulerAngles_SPB< isSubscribable, TEMPLATESPB_FilterParams>::RefreshOVERRIDE(float OutputSignal[3])
	{

		float* ch1 = this->InputChannels[0]->ChannelSignalBufferSingle; 
float* ch2 = this->InputChannels[1]->ChannelSignalBufferSingle; 
float* ch3 = this->InputChannels[2]->ChannelSignalBufferSingle; 
float* ch4 = this->InputChannels[3]->ChannelSignalBufferSingle; 
float* ch5 = this->InputChannels[4]->ChannelSignalBufferSingle; 
float* ch6 = this->InputChannels[5]->ChannelSignalBufferSingle; 
float* ch7 = this->InputChannels[6]->ChannelSignalBufferSingle; 
float* ch8 = this->InputChannels[7]->ChannelSignalBufferSingle; 
float* ch9 = this->InputChannels[8]->ChannelSignalBufferSingle; 

 
		//UserCode_Sectionrefresh
		
		static float accelxptr_;
		static float accelyptr_;
		static float accelzptr_;

		static float gyroxptr_;
		static float gyroyptr_;
		static float gyrozptr_;
	  
		int32_t magxptr = 0;
		int32_t magyptr = 0;
		int32_t magzptr = 0;

	 

		accelxptr_ = (ch2[0]);
		accelyptr_ = (ch1[0]);
		accelzptr_ = -(ch3[0]);

		gyroxptr_ = (ch5[0]) * scale;
		gyroyptr_ = (ch4[0]) * scale;
		gyrozptr_ = -(ch6[0]) *scale;

		// accelerometer/gyro calibration ---------------------------------------- 

		accelxptr_ = (accelxptr_ + 0); // 15191
		accelxptr_ = (accelxptr_ * -1);
		accelyptr_ = (accelyptr_ - 0); //(accelyptr_ - 8178); 
		accelyptr_ = (accelyptr_ * -1);
		accelzptr_ = (accelzptr_ + 0); //(accelzptr_ -3100);
		accelzptr_ = (accelzptr_ * -1);


		accelxptr_ = (accelxptr_ / (float)8192) * (float)9.8;
		accelyptr_ = (accelyptr_ / (float)8192) * (float)9.8;
		accelzptr_ = (accelzptr_ / (float)8192) * (float)9.8;

		gyroxptr_ = ((gyroxptr_ / (float)32.8) * (pi / (float)180)* ((float)1 / (float)scale));
		gyroyptr_ = ((gyroyptr_ / (float)32.8) * (pi / (float)180)* ((float)1 / (float)scale));
		gyrozptr_ = ((gyrozptr_ / (float)32.8) * (pi / (float)180)* ((float)1 / (float)scale));

	  
		//Offsets of magnetometer
		magxptr = ch7[0] + 0;
		magyptr = ch8[0] + -200;
		magzptr = ch9[0] + 0;

		//calibrate magnetometer ---------------------------------------
		magxptr -= 0; //40;//40
		magyptr -= 0; //150;
		magzptr -= 0; //100;//100

		Eigen::Vector3d accel({ (double)accelxptr_, (double)accelyptr_, (double)accelzptr_ });
		Eigen::Vector3d mag({ (double)magxptr, (double)magyptr, (double)magzptr });
		Eigen::Vector3d gyro({ (double)gyroxptr_, (double)gyroyptr_, (double)gyrozptr_ });
          


		float Roll;
		float Pitch;
		float Yaw;
		//compFilter->OrientationFromAccelMag(&accel, &accel, &Roll, &Pitch, &Yaw);
		compFilt->UpdateOrientation(&accel, &gyro, &mag, &Roll, &Pitch, &Yaw);

		float theta_pitch = asin(-accel[0]); 
		OutputSignal[0] = Roll * 180 / pi; //theta_pitch*180 / pi;
		OutputSignal[1] = Pitch * 180 / pi; //theta_pitch*180 / pi;
		OutputSignal[2] = Yaw * 180 / pi; //theta_pitch*180 / pi;
		
//UserCode_Sectionrefresh_end
	}

