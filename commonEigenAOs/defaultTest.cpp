//generated file: C:/Users/hadi/Documents/AERTOSProjects/commonEigenAOs\defaultTest.cpp
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################


 
#if INTEGRATION_TESTS_FOR_commonEigenAOs__defaultTest
 
#include "IntegTestPipeline.h"


#include "AECore.h"
#include "AE_Init.h" 
#include "AEClock.h" 
#include "AEObjects.h" 

DECLARE_ALL_AO_PTR

static void clock1cb(TimerHandle_t xTimerHandle);
static uint32_t sens1_data[1];
static uint32_t sens2_data[1];
static uint32_t sens3_data[1];
static uint32_t sens4_data[1];
static uint32_t sens5_data[1];
static uint32_t sens6_data[1];
static uint32_t sens7_data[1];
static uint32_t sens8_data[1];
static uint32_t sens9_data[1];




//UserCode_Sectiona
#include  "Mex_DCM2AngleFunc.h"
#include  <Dense>
	
#include "ComplFilter.h"

static ComplFilter* compFilter;

//UserCode_Sectiona_end

void RunSelectedIntegrationTest_defaultTest()
{

AE_Init();
 //UserCode_Sectionbeforemain
	
	Mex_DCM2AngleFunc_initialize();
	 
	ComplFilter acs(10, 4);
//	ComplFilter compl = new ComplFilter(3, 4);
	
	
	static float roll;
	static float pitch;
	static float yaw;
	auto accel = Eigen::Vector3d (2, 3, 4);
	auto gyro = Eigen::Vector3d(.4, .5, .4);
	auto mag = Eigen::Vector3d(2, 2, 1);
	
	acs.UpdateOrientation(&accel, &gyro, &mag, &roll, &pitch, &yaw);
	acs.UpdateOrientation(&accel, &gyro, &mag, &roll, &pitch, &yaw);
	
//UserCode_Sectionbeforemain_end
static AEClock<AEObservorSensor, AEObservorInterpretorBaseDUMMY, 9, 0, 0, 0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0> clock1L(100, clock1cb);
clock1 = &clock1L;

static AEObservorSensorFilterOut<> sens1L((uint32_t*) sens1_data, SensorResolution::Resolution16Bit  );
sens1 = &sens1L;

static AEObservorSensorFilterOut<> sens2L((uint32_t*) sens2_data, SensorResolution::Resolution16Bit  );
sens2 = &sens2L;

static AEObservorSensorFilterOut<> sens3L((uint32_t*) sens3_data, SensorResolution::Resolution16Bit  );
sens3 = &sens3L;

static AEObservorSensorFilterOut<> sens4L((uint32_t*) sens4_data, SensorResolution::Resolution16Bit  );
sens4 = &sens4L;

static AEObservorSensorFilterOut<> sens5L((uint32_t*) sens5_data, SensorResolution::Resolution16Bit  );
sens5 = &sens5L;

static AEObservorSensorFilterOut<> sens6L((uint32_t*) sens6_data, SensorResolution::Resolution16Bit  );
sens6 = &sens6L;

static AEObservorSensorFilterOut<> sens7L((uint32_t*) sens7_data, SensorResolution::Resolution16Bit  );
sens7 = &sens7L;

static AEObservorSensorFilterOut<> sens8L((uint32_t*) sens8_data, SensorResolution::Resolution16Bit  );
sens8 = &sens8L;

static AEObservorSensorFilterOut<> sens9L((uint32_t*) sens9_data, SensorResolution::Resolution16Bit  );
sens9 = &sens9L;

static PoseEulerAngles_SPB< false> poseEulerAngles_SPBL; poseEulerAngles_SPBL.InitSPBObserver(StyleOfSPB::EachSPBTask); 
poseEulerAngles_SPB = &poseEulerAngles_SPBL;




//UserCode_Sectionbeforelinks
//UserCode_Sectionbeforelinks_end
static float poseEulerAngles_SPBchBuffer1[1];
poseEulerAngles_SPB->AddSignalFlowLinkToChannelWithCopy1(sens1, poseEulerAngles_SPBchBuffer1, 0);
static float poseEulerAngles_SPBchBuffer2[1];
poseEulerAngles_SPB->AddSignalFlowLinkToChannelWithCopy2(sens2, poseEulerAngles_SPBchBuffer2, 0);
static float poseEulerAngles_SPBchBuffer3[1];
poseEulerAngles_SPB->AddSignalFlowLinkToChannelWithCopy3(sens3, poseEulerAngles_SPBchBuffer3, 0);
static float poseEulerAngles_SPBchBuffer4[1];
poseEulerAngles_SPB->AddSignalFlowLinkToChannelWithCopy4(sens4, poseEulerAngles_SPBchBuffer4, 0);
static float poseEulerAngles_SPBchBuffer5[1];
poseEulerAngles_SPB->AddSignalFlowLinkToChannelWithCopy5(sens5, poseEulerAngles_SPBchBuffer5, 0);
static float poseEulerAngles_SPBchBuffer6[1];
poseEulerAngles_SPB->AddSignalFlowLinkToChannelWithCopy6(sens6, poseEulerAngles_SPBchBuffer6, 0);
static float poseEulerAngles_SPBchBuffer7[1];
poseEulerAngles_SPB->AddSignalFlowLinkToChannelWithCopy7(sens7, poseEulerAngles_SPBchBuffer7, 0);
static float poseEulerAngles_SPBchBuffer8[1];
poseEulerAngles_SPB->AddSignalFlowLinkToChannelWithCopy8(sens8, poseEulerAngles_SPBchBuffer8, 0);
static float poseEulerAngles_SPBchBuffer9[1];
poseEulerAngles_SPB->AddSignalFlowLinkToChannelWithCopy9(sens9, poseEulerAngles_SPBchBuffer9, 0);


//UserCode_Sectionbeforeclock
//UserCode_Sectionbeforeclock_end
clock1->SetObservorToClock(sens1, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sens2, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sens3, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sens4, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sens5, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sens6, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sens7, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sens8, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sens9, AEClock_PrescalerEnum::PRESCALER1);


//AEITEST_END_TestsAfterTimer_commonEigenAOs(5000);
//UserCode_Sectionb
	
	static ComplFilter compFilter_l(100, .97);
	compFilter = &compFilter_l;
	poseEulerAngles_SPB->UserInitialize(compFilter);
//UserCode_Sectionb_end

AEAO::ConfigureAndStart();
}


//UserCode_Sectionc
//UserCode_Sectionc_end


static void clock1cb(TimerHandle_t xTimerHandle) {  
  //UserCode_Sectionclock1before
	
	sens3_data[0] = -1;
		
//UserCode_Sectionclock1before_end 
  
 clock1->Tick(); 
  //UserCode_Sectionclock1after
//UserCode_Sectionclock1after_end 
}


#endif