//generated file: C:/AERTOSProjects/commonAOs\include\AngularDerivativeDiscreteFilter.h
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once 

#include <cstdint>
#include "AEFilter.h"


//UserCode_Sectionheader

//####################################################################################
//This filter will discrete differentiate the signal of a rotating encoder. 
//input: rotating encoder with only a set number of possible values from 0 to countsPerRevolution.
//output: the angular velocity of the rotating encoder. (rad / s)
//####################################################################################

#define templateAng template<int32_t _CountsPerRevolution , int32_t _MinimumAngularVelocitytobeConsideredZero >
#define templateAngArg < _CountsPerRevolution ,  _MinimumAngularVelocitytobeConsideredZero >
//#define templateAng  
//#define templateAngArg 
//UserCode_Sectionheader_end

template<int32_t _CountsPerRevolution , int32_t _MinimumAngularVelocitytobeConsideredZero >
class AngularDerivativeDiscreteFilter //: public Filter<AngularDerivativeDiscreteFilter< _CountsPerRevolution ,  _MinimumAngularVelocitytobeConsideredZero >, 2>
{
  template<class TFilterDerived, uint16_t PastDataBufferSize>
	friend class Filter;

public:



//UserCode_Sectionpubl
	
	/// countsPerRevolution  is the number of discrete angular movements needed to make one full revolution.
	/// MinimumAngularVelocitytobeConsideredZero  is a number that gives (1 / MinimumAngularVelocitytobeConsideredZero) radians per sec. for example: 10 gives .1 rad /sec 
//	static bool Init(uint32_t countsPerRevolution, uint32_t minimumAngularVelocitytobeConsideredZero)
//	{
//		CountsPerRevolution = (float)countsPerRevolution;
//		MinimumAngularVelocitytobeConsideredZero = minimumAngularVelocitytobeConsideredZero;
//		IsInited = true;
//	}
	
//UserCode_Sectionpubl_end

	AngularDerivativeDiscreteFilter();

protected:

//UserCode_Sectionprot
//	static  float CountsPerRevolution;
//	static uint32_t   MinimumAngularVelocitytobeConsideredZero;
//	static bool IsInited;
	
	//float CountsPerRevolution;
//	uint32_t   MinimumAngularVelocitytobeConsideredZero;
	
	uint32_t CounterOfNonChanges;
	float CurrentAngVelocity;
 
	float PreviousValue;
	bool isClockwise;
	 
	
//UserCode_Sectionprot_end
	
	void InitializeImpl(float samplingPeriodOfObservorInSeconds);

	const float*  PastDataCircularBuffer;
	float SamplingPeriodOfObservorInSeconds;
	uint16_t PastDataBufferSize;

private:
	float RunFilter(float newestInput);
	
	//UserCode_Sectionpriv
//UserCode_Sectionpriv_end
	

};

template<int32_t _CountsPerRevolution , int32_t _MinimumAngularVelocitytobeConsideredZero >
inline AngularDerivativeDiscreteFilter< _CountsPerRevolution ,  _MinimumAngularVelocitytobeConsideredZero >::AngularDerivativeDiscreteFilter()
{
	
	//UserCode_Sectionctor
//	this->isClockwise = false;
//	this->CounterOfNonChanges = 0xffffffff;
//	this->PreviousValue = 0xffffffff;
//	this->CurrentAngVelocity = 0xffffffff;
//UserCode_Sectionctor_end
}
 
template<int32_t _CountsPerRevolution , int32_t _MinimumAngularVelocitytobeConsideredZero >
inline void AngularDerivativeDiscreteFilter< _CountsPerRevolution ,  _MinimumAngularVelocitytobeConsideredZero >::InitializeImpl(float samplingPeriodOfObservorInSeconds)
{
	//UserCode_Sectioninit
//	this->SamplingPeriodOfObservorInSeconds = samplingPeriodOfObservorInSeconds;
	this->isClockwise = false;
	this->CounterOfNonChanges = 0;
	this->PreviousValue = 0;
	this->CurrentAngVelocity = 0;
//UserCode_Sectioninit_end
}

template<int32_t _CountsPerRevolution , int32_t _MinimumAngularVelocitytobeConsideredZero >
inline float AngularDerivativeDiscreteFilter< _CountsPerRevolution ,  _MinimumAngularVelocitytobeConsideredZero >::RunFilter(float newestInput)
{
//PastDataCircularBuffer[0] is the newest input
//example: float der = (PastDataCircularBuffer[0] - PastDataCircularBuffer[1]) / this->SamplingPeriodOfObservorInSeconds;
//return the output of the filter
//return der;

//UserCode_Sectionimpl
 
	//AEAssertRuntime(IsInited == true, "you need to call AngularDerivativeDiscreteFilter::Init() for the AngularDerivativeDiscreteFilter ")
	
	
	float CountsPerRevolution = _CountsPerRevolution;
	uint32_t MinimumAngularVelocitytobeConsideredZero = _MinimumAngularVelocitytobeConsideredZero;
	 
	float PIf = 3.14159;
	//this->RadiansPerCount = ((2 * this->PIf) / CountsPerRevolution);/* ;*/
	float DeltaRadiansPerDiscreteStep = 2 * PIf;
	DeltaRadiansPerDiscreteStep = DeltaRadiansPerDiscreteStep / CountsPerRevolution;
 
	if (newestInput == PreviousValue)
	{
		//there has not been any change so up the counter
		CounterOfNonChanges = CounterOfNonChanges >= 0xffffffff ? 0xffffffff : CounterOfNonChanges + 1;

		//calculate what the velocity would be had it changed at this point
		float potentialVelocity = DeltaRadiansPerDiscreteStep / (CounterOfNonChanges * this->SamplingPeriodOfObservorInSeconds);

		//if potential is less than MinimumAngularVelocitytobeConsideredZero, than zero
		potentialVelocity = potentialVelocity < (1 / MinimumAngularVelocitytobeConsideredZero) ? 0 : potentialVelocity;

                
		//change velocity based on if lcockwise or anitclockise 
		if (isClockwise == true)
		{
			//if potentialVelocity < CurrentVelocity than use the new slower potential velocity as a way to show 
//that it must be slowing down
			potentialVelocity = abs(potentialVelocity) * -1;
			if (potentialVelocity > CurrentAngVelocity)
			{
				CurrentAngVelocity = potentialVelocity;
			}
		}
		else
		{ 
			potentialVelocity = abs(potentialVelocity);
			if (potentialVelocity < CurrentAngVelocity)
			{
				CurrentAngVelocity = potentialVelocity;
			}
		}
                


	}

	else if (newestInput > PreviousValue)
	{
		isClockwise = true;
		
		CounterOfNonChanges = CounterOfNonChanges == 0 ? 1 : CounterOfNonChanges;
		// if there was a change in position, update the velocity and reset the counter. 
		float potentialVelocity = -DeltaRadiansPerDiscreteStep / (CounterOfNonChanges * this->SamplingPeriodOfObservorInSeconds);
		CurrentAngVelocity = potentialVelocity;
		CounterOfNonChanges = 0;
	}
	else if (newestInput < PreviousValue)
	{
		isClockwise = false;
		
		CounterOfNonChanges = CounterOfNonChanges == 0 ? 1 : CounterOfNonChanges;
		// if there was a change in position, update the velocity and reset the counter. 
		float potentialVelocity = DeltaRadiansPerDiscreteStep / (CounterOfNonChanges * this->SamplingPeriodOfObservorInSeconds);
		CurrentAngVelocity = potentialVelocity;
		CounterOfNonChanges = 0;
	}

	PreviousValue = newestInput;


	return CurrentAngVelocity;
//UserCode_Sectionimpl_end
 
}


//UserCode_Sectionfunc
//UserCode_Sectionfunc_end