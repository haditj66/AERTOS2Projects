//generated file: C:/Users/hadi/Documents/AERTOSProjects/commonAOs\include\PID_WithDesiredInputAsChannel_SPB.h
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once


#include "AESPBObservorOutputType.h"
#include "AEUtils.h"
#include "FreeRTOS.h"
#include "AEFilter.h"

#include "AEIntegrationTesting.h"

//UserCode_Sectionheader
#define  SizeOfIntegralQueue  10
//UserCode_Sectionheader_end

template<bool isSubscribable, TEMPLATESPB_Filters>
	class PID_WithDesiredInputAsChannel_SPB :
		public AESPBObservorOutputType <1, 2, isSubscribable,
TEMPLATESPB_FilterParams,
1, false,
1, false>
	{
	public:
		PID_WithDesiredInputAsChannel_SPB();
		
		//UserCode_Sectionpublic
//UserCode_Sectionpublic_end


	protected: uint8_t kpfrom0to100; 
public: uint8_t  Getkpfrom0to100()   const {return kpfrom0to100; }

protected: uint8_t kifrom0to100; 
public: uint8_t  Getkifrom0to100()   const {return kifrom0to100; }

protected: uint8_t kdfrom0to100; 
public: uint8_t  Getkdfrom0to100()   const {return kdfrom0to100; }

protected: float maxPossibleError; 
public: float  GetmaxPossibleError()   const {return maxPossibleError; }

protected: float maxpossibleRateOfChangeOfControlVariable; 
public: float  GetmaxpossibleRateOfChangeOfControlVariable()   const {return maxpossibleRateOfChangeOfControlVariable; }

protected: float mapOutputTOMin; 
public: float  GetmapOutputTOMin()   const {return mapOutputTOMin; }

protected: float mapOutputTOMax; 
public: float  GetmapOutputTOMax()   const {return mapOutputTOMax; }

protected: float offsetFromZero; 
public: float  GetoffsetFromZero()   const {return offsetFromZero; }


public: void UserInitialize(uint8_t _kpfrom0to100 , uint8_t _kifrom0to100 , uint8_t _kdfrom0to100 , float _maxPossibleError , float _maxpossibleRateOfChangeOfControlVariable , float _mapOutputTOMin  = -100000, float _mapOutputTOMax  = 100000, float _offsetFromZero  = 0)
	{
		kpfrom0to100 =  _kpfrom0to100;
kifrom0to100 =  _kifrom0to100;
kdfrom0to100 =  _kdfrom0to100;
maxPossibleError =  _maxPossibleError;
maxpossibleRateOfChangeOfControlVariable =  _maxpossibleRateOfChangeOfControlVariable;
mapOutputTOMin =  _mapOutputTOMin;
mapOutputTOMax =  _mapOutputTOMax;
offsetFromZero =  _offsetFromZero;

		
		//UserCode_SectionuserInited
//UserCode_SectionuserInited_end
		
		userInitialized = true;
	}
private: bool userInitialized = false;
protected: void CheckIfConfiguredProperly() const override  
	{
		//PID_WithDesiredInputAsChannel_SPB::CheckIfConfiguredProperly();
		if (userInitialized == false)
		{
			// you did not initialize one of your AEobjects
			AEAssertRuntime(userInitialized == true, "user did not call the UserInitailize function for  PID_WithDesiredInputAsChannel_SPB"); 
		} 
		 
	}
	
	private:
	//UserCode_Sectionprivate
		
	protected:
		float previousValue;
	
		uint16_t _indexesq;
		float total;
		
		float EsQueue[SizeOfIntegralQueue];
		 
		float _Ti;
		 
		float Kp;
		float Ki;
		float Kd;
		
		
		
		uint16_t GetIndex() { return _indexesq; }
		;
		void    SetIndex(uint16_t value) { _indexesq = value >= SizeOfIntegralQueue ? 0 : value; }
		;

		
		
		void InitializeObservor() override
		{
				
			//everything needs to be scaled in such a way that Kp Ki Kd are the same weights regardless
	//of the changes in SizeOfIntegralQueue or Ti. the output of this PID will always be a number
	//between pid_out = 0 - 100000 . this number represents how much the plant, or controlling
	//actuator, needs to work to get to the desiredinput. 0 means no work needs to be done while 
	// 100000 is the max amount of work that needs to be done. It is up to the control variable, 
	//aka actuator, to determine what to do with the given pid_out.

	//the weights of the pid should add up to 100
			configASSERT((kpfrom0to100 + kifrom0to100 + kdfrom0to100) == 100);
			Kp = (float)kpfrom0to100;
			Ki = (float)kifrom0to100;
			Kd = (float)kdfrom0to100; 
         

			//first I get what the max error value could be theoretically possible from the kp term
			float kpmax = Kp * maxPossibleError;

			//now I need to get the max error possible from the ki term. First I need to make sure that
			//changing the Ti and the SizeOfIntegralQueue will not ultimately change the weight Ki as well.
			//For this I introduce a factor Kifactor such that Kifactor = (1/ Ti*SizeOfIntegralQueue) . 
			//thus max error term of the Ki term becomes, 
			//Kimax = Ki * Kifactor * Ti*SizeOfIntegralQueue * maxPossibleError;
			//which simplifies to Kimax = Ki  *  maxPossibleError;
			//this means that Ki should be modified to Ki = Ki * Kifactor; to rid the effects of Ti
			_Ti = 1 / this->GetFrequencyIRefreshAt(); // 1 / this->GetFrequencyIRefreshAt();
			float Kifactor = 1 / (_Ti * SizeOfIntegralQueue);
			float Kimax = Ki * Kifactor * _Ti*SizeOfIntegralQueue * maxPossibleError;
			Ki = Ki * Kifactor;



			//now to get kdmax. again I want to negate the influence of e(n) - e(n-1) / Ti for kdmax.
			//so again I introduce the factor kdfactor = Ti /(e(n) - e(n-1)) 
			float Kdfactor = (_Ti / maxpossibleRateOfChangeOfControlVariable);
			float Kdmax = Kd * Kdfactor * (maxpossibleRateOfChangeOfControlVariable / _Ti) * maxPossibleError;
			Kd = Kd * Kdfactor;

			//now to get the max possible error. the output pid_out will be scaled by this value
			this->maxPossibleError = kpmax + Kimax + Kdmax;


			//DesiredInput = desiredInput;
			previousValue = 0;
			total = 0;
			_indexesq = 0;
			//populate the queue with zeros
			for (int i = 0; i < SizeOfIntegralQueue; i++)
			{
				EsQueue[i] = 0;
			}
		
		}
		
//UserCode_Sectionprivate_end

		void RefreshOVERRIDE(float OutputSignal[1]) override;

	};


//UserCode_Sectionfunc
//UserCode_Sectionfunc_end


template<bool isSubscribable, TEMPLATESPB_FiltersFunctionParams>
	inline PID_WithDesiredInputAsChannel_SPB< isSubscribable, TEMPLATESPB_FilterParams>::PID_WithDesiredInputAsChannel_SPB()
	{
		//UserCode_Sectionctor
//UserCode_Sectionctor_end
	}

template<bool isSubscribable, TEMPLATESPB_FiltersFunctionParams>
	inline void PID_WithDesiredInputAsChannel_SPB< isSubscribable, TEMPLATESPB_FilterParams>::RefreshOVERRIDE(float OutputSignal[1])
	{

		float* ch1 = this->InputChannels[0]->ChannelSignalBufferSingle; 
float* ch2 = this->InputChannels[1]->ChannelSignalBufferSingle; 

 
		//UserCode_Sectionrefresh
		
		float* input = ch1;
		float desiredInput = ch2[0];
 
		 

		float e = input[0] - desiredInput;
		//float e = DesiredInput-input[0]  ;

		//remember input needs to be the error term at current time
		float e_s1 = Kp * (e);

		//for integral term, I need to create a queue to push in new terms.
		//EsQueue.push(input);//push in the new error term in line.
		//EsQueue.pop();//delete the last one in queue

		//first get the last value in the queue
		//take away that value from the total 
		float aa = EsQueue[GetIndex()];
		//		if (isnan(aa))
		//		{
		//			sfsfscsf++;
		//       
		//		}
		total -= _Ti * aa;
		//add the new value and update the old value
		total += _Ti * e;
		EsQueue[GetIndex()] = e;

		float e_s2 = Ki * total;

		/*
		float e_s2 = 0;
		for (int i = 1; i < SizeOFQueue; i++)
		{
			//move the first one back
			EsQueue[i-1] = EsQueue[i];
			e_s2 += _Ti*EsQueue[i] * weightArrayl[i];
			}
			//add the newest term now
			EsQueue[SizeOFQueue-1] = input;
			e_s2 += _Ti*EsQueue[SizeOFQueue-1] * weightArrayl[SizeOFQueue-1];
			e_s2 = Ki*e_s2;//multiply by Ki term
				*/


		float e_s3 = 0;
		//I need to divide this by th sampling time because remember this
		//is not the error term derivative yet because I had multiplied the 
		//sampling time from before over here _Ti*EsQueue[19] * weightArrayl[19].
		//e_s3 = (EsQueue[SizeOFQueue-1] - EsQueue[SizeOFQueue-2]) / _Ti;
		e_s3 = (input[0] - previousValue) / _Ti;
		e_s3 = e_s3 * Kd; //multiple by Kd term

			//incrmemnt the index;
		previousValue = input[0];
		SetIndex((GetIndex() + 1));
		/*
		if(iiig >= 5 )
		{
		  PROJECT::BSP::DisplayMsg("KP :  \n",e_s1);
		  PROJECT::BSP::DisplayMsg("KI :  \n",e_s2);
		  PROJECT::BSP::DisplayMsg("KD :  \n",e_s3);
		  iiig = 0;
		 }
		 iiig++;
		 */

		 //add terms together and map value from -100000 - 100000
		float pid_out;
		pid_out = AE_Map((e_s1 + e_s2 + e_s3), -maxPossibleError, maxPossibleError, mapOutputTOMin, mapOutputTOMax);
		pid_out = pid_out < 0 ? (pid_out - offsetFromZero) : pid_out;
		pid_out = pid_out >= 0 ? (pid_out + offsetFromZero) : pid_out;
        
		/*if(isInputMapped == true)
		{ 
		  pid_out = AE_Map((e_s1 + e_s2 + e_s3), -maxPossibleError, maxPossibleError, MapOutputTOMin, MapOutputTOMax);
		  //DesiredInput= AE_Map(DesiredInput,MapInputFromMin, MapInputFromMax, MapInputTOMin, MapInputTOMax);
		}
		else
		{
          
		}
	 pid_out = AE_Map((e_s1 + e_s2 + e_s3), -maxPossibleError, maxPossibleError, -100000, 100000);*/
		OutputSignal[0] = pid_out;
		
//UserCode_Sectionrefresh_end
	}

