//generated file: C:/AERTOSProjects/blinky\defaultTest.cpp
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################


 
#if INTEGRATION_TESTS_FOR_blinky__defaultTest
 
#include "IntegTestPipeline.h"


#include "AECore.h"
#include "AE_Init.h" 
#include "AEClock.h" 
#include "AEObjects.h" 

DECLARE_ALL_AO_PTR

static void clock1_callback(TimerHandle_t xTimerHandle);
static int16_t sineSensor_data[1];
static int16_t sengpioSensorsor2_data[1];




//UserCode_Sectiona

#include "AERand.h"
const int sinDataSize = 1000;
static float NoisySineData[sinDataSize];
static int indexSine = 0;
static bool  firstTick = false;  

//UserCode_Sectiona_end

void RunSelectedIntegrationTest_defaultTest()
{

AE_Init();
 //UserCode_Sectionbeforemain
	
	const float Pi = 3.14159;
	for (int i = 0; i < sinDataSize; i++)
	{ 
		float noise = AE_rand::getRandomGaussianDistribution(0,.01);
		NoisySineData[i] = (sin((i*  Pi / (sinDataSize ))) + noise);
		NoisySineData[i] = NoisySineData[i] * 100; //scale it for a pwm value
		
	}
	
	  
	
	
	
//UserCode_Sectionbeforemain_end









static AEClock<AEObservorSensor, AEObservorInterpretorBaseDUMMY, 1, 0, 0, 0, 0, 0,1, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0> clock1L(1000, clock1_callback);
clock1 = &clock1L;

static AEObservorSensorFilterOut<> sineSensorL((int16_t*) sineSensor_data, SensorResolution::Resolution16Bit  );
sineSensor = &sineSensorL;

static AEObservorSensorFilterOut<> sengpioSensorsor2L((int16_t*) sengpioSensorsor2_data, SensorResolution::Resolution16Bit  );
sengpioSensorsor2 = &sengpioSensorsor2L;

static AverageSPB< false,  4> averageSPBL; averageSPBL.InitSPBObserver(StyleOfSPB::EachSPBTask); 
averageSPB = &averageSPBL;

static IfRightOnSPB< false> ifRightOnSPBL; ifRightOnSPBL.InitSPBObserver(StyleOfSPB::EachSPBTask); 
ifRightOnSPB = &ifRightOnSPBL;

static PWMDriverU pWMDriverU_L; pWMDriverU_L.Init(AEPriorities::MediumPriority);
pWMDriverU = &pWMDriverU_L;




//UserCode_Sectionbeforelinks
//UserCode_Sectionbeforelinks_end
static float averageSPBchBuffer1[4];
averageSPB->AddSignalFlowLinkToChannelWithCopy1(sineSensor, averageSPBchBuffer1, 0);
static float ifRightOnSPBchBuffer1[1];
ifRightOnSPB->AddSignalFlowLinkToChannelWithCopy1(averageSPB, ifRightOnSPBchBuffer1, 0);
static float ifRightOnSPBchBuffer2[1];
ifRightOnSPB->AddSignalFlowLinkToChannelWithCopy2(sengpioSensorsor2, ifRightOnSPBchBuffer2, 0);
pWMDriverU->SetToSPBTick(ifRightOnSPB, 0);



//UserCode_Sectionbeforeclock
//UserCode_Sectionbeforeclock_end
clock1->SetObservorToClock(sineSensor, AEClock_PrescalerEnum::PRESCALER1);
clock1->SetObservorToClock(sengpioSensorsor2, AEClock_PrescalerEnum::PRESCALER4);


//AEITEST_END_TestsAfterTimer_blinky(5000);
//UserCode_Sectionb
	pWMDriverU->UserInitialize(PWMPERIPHERAL_inst1);
	
//UserCode_Sectionb_end

AEAO::ConfigureAndStart();
}


//UserCode_Sectionc
//UserCode_Sectionc_end


static void clock1_callback(TimerHandle_t xTimerHandle) {  
  //UserCode_Sectionclock1before
	
	indexSine = indexSine == 1000 ? 0 : indexSine+1;
	sineSensor_data[0] = NoisySineData[indexSine];
	sengpioSensorsor2_data[0] = (int16_t)!GPIOPERIPHERAL_inst1->GPIO_ReadPin();
	
	if (firstTick == false)
	{
		pWMDriverU->StartPWMFromSPBLinked(0,true);
		firstTick = true;
	}
	
//UserCode_Sectionclock1before_end 
  
 clock1->Tick(); 
  //UserCode_Sectionclock1after
//UserCode_Sectionclock1after_end 
}


#endif