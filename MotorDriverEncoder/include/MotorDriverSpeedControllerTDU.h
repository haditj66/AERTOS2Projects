//generated file: C:/Users/hadi/Documents/AERTOSProjects/MotorDriverEncoder\include\MotorDriverSpeedControllerTDU.h
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################


#pragma once

#include "AEUtilityAsService.h" 

#include "AEPublishSubscribeManager.h" 

#include "ActionRequestObjectArgTDU.h"
 
#include "AE_TDUAsService.h" 

#include "MotorDriverSpeedControllerTDU_ServiceGen.h"




//UserCode_Sectionheader
//UserCode_Sectionheader_end

class MotorDriverSpeedControllerTDU :   
	 public AEService< 10 , AENullActionRequest, AENullActionRequest, AENullActionRequest, ActionRequestObjectArgTDU3<int16_t , float , bool , bool, 10, MotorDriverSpeedControllerTDU>, ActionRequestObjectArgTDU2<float , bool , bool, 10, MotorDriverSpeedControllerTDU>, AENullActionRequest >
{
public: 

	//UserCode_Sectionpublic
	float DeltaPWM;
	float CurrentAngularVelocity;
	float CurrentPosition;
//UserCode_Sectionpublic_end
	 
	MotorDriverSpeedControllerTDU ()
	{ 
		 //ActionReq1.ServiceName = "Transmit";
		
		
		ActionReq4.ServiceName = "MoveToAngularPositionWithSpeed";
		ActionReq5.ServiceName = "MoveAtSpeed";
		 
		 
		MotorDriverSpeedControllerTDU_CTOR
		
		//UserCode_Sectionctor
//UserCode_Sectionctor_end
		 	
	}
	MotorDriverSpeedControllerTDU_Service
	
	
	protected: AEPWM* pwmPeripheral; 
public: AEPWM*  GetpwmPeripheral()   const {return pwmPeripheral; }

protected: AEGPIOOutput* gpiotoChangeDirections; 
public: AEGPIOOutput*  GetgpiotoChangeDirections()   const {return gpiotoChangeDirections; }

protected: int32_t DesiredPosition; 
public: int32_t  GetDesiredPosition()   const {return DesiredPosition; }
public:  void SetDesiredPosition(int32_t  _DesiredPosition){DesiredPosition = _DesiredPosition; }

protected: float MaxDeltaPWMPerSec; 
public: float  GetMaxDeltaPWMPerSec()   const {return MaxDeltaPWMPerSec; }


public: void UserInitialize(AEPWM* _pwmPeripheral , AEGPIOOutput* _gpiotoChangeDirections , int32_t _DesiredPosition , float _MaxDeltaPWMPerSec  = 20)
	{
		pwmPeripheral =  _pwmPeripheral;
gpiotoChangeDirections =  _gpiotoChangeDirections;
DesiredPosition =  _DesiredPosition;
MaxDeltaPWMPerSec =  _MaxDeltaPWMPerSec;

		
		//UserCode_SectionuserInited
//UserCode_SectionuserInited_end
		
		userInitialized = true;
	}
private: bool userInitialized = false;
protected: void CheckIfConfiguredProperly() const override  
	{
		//MotorDriverSpeedControllerTDU::CheckIfConfiguredProperly();
		if (userInitialized == false)
		{
			// you did not initialize one of your AEobjects
			AEAssertRuntime(userInitialized == true, "user did not call the UserInitailize function for  MotorDriverSpeedControllerTDU"); 
		} 
		 
	}
	
protected: 
	
	//UserCode_Sectionprot
	
	float PreviousPWM;
	float PreviousAngularVelocity;
	
	
	void ChangeDutyCycle(float dutyCycleToChangeto)
	{

		if (dutyCycleToChangeto >= 0)
		{
			gpiotoChangeDirections->GPIO_SetHigh(); 
		}
		else
		{
			gpiotoChangeDirections->GPIO_SetLow(); 
		}
		pwmPeripheral->ChangeDutyCycle(abs(dutyCycleToChangeto));

	}
//UserCode_Sectionprot_end
	
	
	//example for waiting on an event
	//actReq->WaitForEvent<SomeOther_Sig>(
	//				[](void* s, AEEventDiscriminator_t* evt)->void {
	//					//SomeOther_Sig* sssc = (SomeOther_Sig*)evt->evt;
	//					AEPrint("Event SomeOther_Sig recieved"); 
	//					return;
	//				}
	//				, 500);
	
	//dont forget to return the service value when finished
	//actReq->SetReturnArg(1); 
	
	//return true in the update function for tdus when the service is done.
	
	//=====================================
	//Normal services
	//=====================================
	  
	  
	  
	
	
	//=====================================
	//TDU services
	//=====================================
	void _MoveToAngularPositionWithSpeed(int16_t StepCountToTurnTo, float speedToTurnAt, bool withRamping) 
   {

         //UserCode_SectionMoveToAngularPositionWithSpeed
//UserCode_SectionMoveToAngularPositionWithSpeed_end 
   }

void _MoveToAngularPositionWithSpeedCancelCleanup() 
   {

         //UserCode_SectionMoveToAngularPositionWithSpeedcancel
//UserCode_SectionMoveToAngularPositionWithSpeedcancel_end 
   }

    bool _MoveToAngularPositionWithSpeedUpdate(ActionRequestObjectArgTDU3<int16_t , float , bool , bool, 10, MotorDriverSpeedControllerTDU>* request, int16_t StepCountToTurnTo, float speedToTurnAt, bool withRamping) 
   {

         //UserCode_SectionMoveToAngularPositionWithSpeedu
	   
	   	    
	   //DeltaPWM comes from the pidVelocitySPB output
	   DeltaPWM = this->LinkedSPBData[0];
	   
	   //CurrentPosition comes from the EncoderPosition_spb output
	   if (CurrentPosition == DesiredPosition)      
	   {
		   ChangeDutyCycle(0);
		   PreviousPWM = 0;
		   return true;
	   }
	   
	   //DeltaPWM comes from the pidVelocitySPB output
	   float PWMStrength = PreviousPWM + DeltaPWM;
  
	   //for anticlockwise
	     /*
	     if(((CurrentPosition - DesiredPosition ) < 20) && ((CurrentPosition - DesiredPosition ) > -20)) 
	     {
	       if(abs(PWMStrength) < 20)
	       {    
	       PWMStrength = DeltaPWM
	       }
	       if(PWMStrength < 20 && PWMStrength > 0)
	       {    
        
	         PWMStrength = 20;
	         PreviousPWM = PWMStrength;
	         ChangeDutyCycle(PreviousPWM);

	     }
	       if(PWMStrength > -20 && PWMStrength < 0)
	       {
	             PWMStrength = -20;
	     PreviousPWM = PWMStrength;
	     ChangeDutyCycle(PreviousPWM);
	 }
	 }
   */
  
  // PWMStrength = (PWMStrength < 20 && PWMStrength > 0) ? 20 : PWMStrength;
   //PWMStrength = (PWMStrength > -20 && PWMStrength < 0)? -20 : PWMStrength;
 
   /*float max = 20;
   PWMStrength = PWMStrength > max ? max : PWMStrength;
   PWMStrength = PWMStrength < -max ? -max : PWMStrength;*/
  
	   bool isNegativePWM = DeltaPWM < 0;
	   //PWMStrength = abs(PWMStrength);

	   //calculate the change in pwm stregth and adjust for max allowable change
	   float pwmPerSec = (abs(DeltaPWM)) * (this->FrequencyIUpdateAt); //LoopForThisObject->GetFrequency());

	   //if pwmPerSec is greater than max allowable
	   /*if (pwmPerSec > (MaxDeltaPWMPerSec* (this->LoopForThisObject->GetFrequency())) )
	   {
	   	float newDeltaPWM  = (MaxDeltaPWMPerSec );//  / (this->LoopForThisObject->GetFrequency()));// + PreviousPWM;
	   	newDeltaPWM = isNegativePWM == true ? newDeltaPWM * -1 : newDeltaPWM; 
                
                
	   	ChangeDutyCycle(newDeltaPWM + PreviousPWM);
				PreviousPWM = newDeltaPWM + PreviousPWM;
	}
	else
	{ */
	   ChangeDutyCycle(PWMStrength);
	   PreviousPWM = PWMStrength;
	   //}

	   PreviousPWM = PreviousPWM < -100  ? -100 : PreviousPWM;
	   PreviousPWM = PreviousPWM >  100  ? 100 : PreviousPWM;
	   
	   return false;
	   
//UserCode_SectionMoveToAngularPositionWithSpeedu_end 
    return true; 
    }
  
	void _MoveAtSpeed(float speedToTurnAt, bool withRamping) 
   {

         //UserCode_SectionMoveAtSpeed
//UserCode_SectionMoveAtSpeed_end 
   }

void _MoveAtSpeedCancelCleanup() 
   {

         //UserCode_SectionMoveAtSpeedcancel
	   
//UserCode_SectionMoveAtSpeedcancel_end 
   }

    bool _MoveAtSpeedUpdate(ActionRequestObjectArgTDU2<float , bool , bool, 10, MotorDriverSpeedControllerTDU>* request, float speedToTurnAt, bool withRamping) 
   {

         //UserCode_SectionMoveAtSpeedu

	   
//UserCode_SectionMoveAtSpeedu_end 
    return true; 
    }
  
	  
	 
	  

};




//UserCode_Sectionfunc
//UserCode_Sectionfunc_end