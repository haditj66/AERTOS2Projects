//generated file: C:/AERTOSProjects/mpu6050driver\include\mpuLoopAcquisition.h
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################

#pragma once
 
#include "AELoopObject.h" 
#include  "AEObjects.h"   

//UserCode_Sectionheader
//UserCode_Sectionheader_end

class mpuLoopAcquisition : public AELoopObject
{
	
public:
	mpuLoopAcquisition() { 
		  //UserCode_Sectionctor
//UserCode_Sectionctor_end
	} 
	
 //UserCode_Sectionpublic
//UserCode_Sectionpublic_end
	
protected: AEI2C* I2cPeripheralToUse; 
public: AEI2C*  GetI2cPeripheralToUse()   const {return I2cPeripheralToUse; }


public: void UserInitialize(AEI2C* _I2cPeripheralToUse  = I2CPERIPHERAL_inst1)
	{
		I2cPeripheralToUse =  _I2cPeripheralToUse;

		
		//UserCode_SectionuserInited
//UserCode_SectionuserInited_end
		
		userInitialized = true;
	}
private: bool userInitialized = false;
protected: void CheckIfConfiguredProperly() const override  
	{
		//mpuLoopAcquisition::CheckIfConfiguredProperly();
		if (userInitialized == false)
		{
			// you did not initialize one of your AEobjects
			AEAssertRuntime(userInitialized == true, "user did not call the UserInitailize function for  mpuLoopAcquisition"); 
		} 
		 
	}

protected: 
	
		void StartAOLoopObject()  override
	{
//		AELoopSubscribe(Button1, AELoopObject1Test, Button1_Callback);
		//UserCode_Sectionstartae
		
		
//		uint8_t I2Cbuffer2[100];
		I2cPeripheralToUse->WriteBytes(0x68, 0x6B, 1, nullptr);
		
//UserCode_Sectionstartae_end
	}
	
	void Update() override {
		
		//UserCode_Sectionupdate
		
		
		//LEAVE EVERYTHING EXACTLY AS IT IS. YES EVEN THe UNNECESSARY   txcmplt = false;  . I dont know why it only works with them!!!!!!!!! FUCK I2C!!!!!!
		
		I2cPeripheralToUse->WriteBytes(0x68, 0x3B, 0, nullptr);
		//wait for that tx to finish
//		while (txcmplt == false) {}
		txcmplt = false;
		
		
		I2cPeripheralToUse->ReadBytes(0x68, 14, nullptr);
		//		while (rxcmplt == false) {}
		rxcmplt = false;
		
		uint8_t  firstHalf = I2cPeripheralToUse->GetI2CBuffer()[0]; 
		uint8_t  secondHalf = I2cPeripheralToUse->GetI2CBuffer()[1];
	
		//from that read buffer, get the accel and gyro values
		int16_t ax = (((int16_t)(I2cPeripheralToUse->GetI2CBuffer()[0])) << 8) | I2cPeripheralToUse->GetI2CBuffer()[1];
		int16_t ay = (((int16_t)(I2cPeripheralToUse->GetI2CBuffer()[2])) << 8) | I2cPeripheralToUse->GetI2CBuffer()[3];
		int16_t az = (((int16_t)(I2cPeripheralToUse->GetI2CBuffer()[4])) << 8) | I2cPeripheralToUse->GetI2CBuffer()[5];
		int16_t gx = (((int16_t)I2cPeripheralToUse->GetI2CBuffer()[8]) << 8) | I2cPeripheralToUse->GetI2CBuffer()[9];
		int16_t gy = (((int16_t)I2cPeripheralToUse->GetI2CBuffer()[10]) << 8) | I2cPeripheralToUse->GetI2CBuffer()[11];
		int16_t gz = (((int16_t)I2cPeripheralToUse->GetI2CBuffer()[12]) << 8) | I2cPeripheralToUse->GetI2CBuffer()[13];
		
		sensorForAccelx->Dataptr[0] = ay; //switch x and y!!
		sensorForAccely->Dataptr[0] = ax;//switch x and y!!
		sensorForAccelz->Dataptr[0] = az;
		
		sensorForgyrox->Dataptr[0] = gy;//switch x and y!!
		sensorForgyroy->Dataptr[0] = gx;//switch x and y!!
		sensorForgyroz->Dataptr[0] = gz;
		
		
		//TODO: put this in an spb
		
		
//		accelxptr_ = (accelxptr_ + 0); //15191);
//		accelxptr_ = (accelxptr_ * -1);
//		accelyptr_ = (accelyptr_ - 0); //7500);//(accelyptr_ - 8178); 
//		accelyptr_ = (accelyptr_ * -1);
//		accelzptr_ = (accelzptr_ - 0); //3100);//(accelzptr_ -3313);
//		accelzptr_ = (accelzptr_ * -1);
//
//
//		accelxptr_ = (double)((double)((double)accelxptr_ / (double)8192) * (double)9.8);
//		accelyptr_ = (double)((double)((double)accelyptr_ / (double)8192) * (double)9.8);
//		accelzptr_ = (double)((double)((double)accelzptr_ / (double)8192) * (double)9.8);
//
//		gyroxptr_ = ((gyroxptr_ / (double)32.8) * (pi / (double)180)* ((double)1 / (double)scale));
//		gyroyptr_ = ((gyroyptr_ / (double)32.8) * (pi / (double)180)* ((double)1 / (double)scale));
//		gyrozptr_ = ((gyrozptr_ / (double)32.8) * (pi / (double)180)* ((double)1 / (double)scale));


		
		clockForMpu->TickWithoutTimer();
		
		
//UserCode_Sectionupdate_end
		 
	} 
	
	//UserCode_Sectionprotect
	
	bool txcmplt;
	bool rxcmplt;
//UserCode_Sectionprotect_end
	
};


//UserCode_Sectionfuncs
//UserCode_Sectionfuncs_end