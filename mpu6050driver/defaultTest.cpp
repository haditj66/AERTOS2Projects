//generated file: C:/AERTOSProjects/mpu6050driver\defaultTest.cpp
//**********************************************************************
//this is an auto-generated file using the template file located in the directory of C:\CodeGenerator\CodeGenerator\bin\Debug\..\..\FileTemplates\Files
//ONLY WRITE CODE IN THE UserCode_Section BLOCKS
//If you write code anywhere else,  it will be overwritten. modify the actual template file if needing to modify code outside usersection blocks.

//############################################### 
//this is an autogenerated file using cgen's macro2 command. Dont modify this file here unless it is in user sections 
//###############################################


 
#if INTEGRATION_TESTS_FOR_mpu6050driver__defaultTest
 
#include "IntegTestPipeline.h"


#include "AECore.h"
#include "AE_Init.h" 
#include "AEClock.h" 
#include "AEObjects.h" 

DECLARE_ALL_AO_PTR

#include "mpuLoopAcquisition.h"
static mpuLoopAcquisition* loopobjectForGettingMPUData;
static int16_t sensorForAccelx_data[1];
static int16_t sensorForAccely_data[1];
static int16_t sensorForAccelz_data[1];
static int16_t sensorForgyrox_data[1];
static int16_t sensorForgyroy_data[1];
static int16_t sensorForgyroz_data[1];




//UserCode_Sectiona
#include "MPU6050.h"

bool txcmplt;
bool rxcmplt;


 
 

//UserCode_Sectiona_end

void RunSelectedIntegrationTest_defaultTest()
{

AE_Init();
 //UserCode_Sectionbeforemain
	
//	MPU6050 mpu(I2CPERIPHERAL1_Name);
//	
//	mpu.initialize();

 
	
	
	

	static  int16_t erx; static  int16_t ery; static  int16_t erz;
	static  int16_t gx; static  int16_t gy; static  int16_t gz;
	static int16_t mx; static int16_t my; static int16_t mz;

	double const pi = 3.14159265;
	int16_t const scale = 1000;
	
//	txcmplt = false;
//	rxcmplt = false;
//	I2CPERIPHERAL_inst1->SetI2C_MasterTxCpltCallback([](AEI2C* i)->void {
//		txcmplt = true;
//	});
//	I2CPERIPHERAL_inst1->SetI2C_MasterRxCpltCallback([](AEI2C* i)->void {
//		rxcmplt = true;
//	});
 
#ifdef  ascasvsg
				  


	
	uint8_t I2Cbuffer2[100];
	I2CPERIPHERAL_inst1->WriteBytes(0x68, 0x6B, 1, I2Cbuffer2);
//	while (txcmplt == false) {}
	
	
		//readBytes(0x68,0x3B,6,err,1000);   
	while (true)
	{
		
		//LEAVE EVERYTHING EXACTLY AS IT IS. YES EVEN THe UNNECESSARY   txcmplt = false;  . I dont know why it only works with them!!!!!!!!! FUCK I2C!!!!!!
		
		I2CPERIPHERAL_inst1->WriteBytes(0x68, 0x3B, 0, nullptr);
		//wait for that tx to finish
//		while (txcmplt == false) {}
		txcmplt = false;
		
		
		I2CPERIPHERAL_inst1->ReadBytes(0x68, 14, nullptr);
//		while (rxcmplt == false) {}
		rxcmplt = false;
		
		uint8_t  firstHalf = I2CPERIPHERAL_inst1->GetI2CBuffer()[0]; 
		uint8_t  secondHalf = I2CPERIPHERAL_inst1->GetI2CBuffer()[1];
	
			//from that read buffer, get the accel and gyro values
		int16_t ax = (((int16_t)(I2CPERIPHERAL_inst1->GetI2CBuffer()[0])) << 8) | I2CPERIPHERAL_inst1->GetI2CBuffer()[1];
		int16_t ay = (((int16_t)(I2CPERIPHERAL_inst1->GetI2CBuffer()[2])) << 8) | I2CPERIPHERAL_inst1->GetI2CBuffer()[3];
		int16_t az = (((int16_t)(I2CPERIPHERAL_inst1->GetI2CBuffer()[4])) << 8) | I2CPERIPHERAL_inst1->GetI2CBuffer()[5];
		int16_t gx = (((int16_t)I2CPERIPHERAL_inst1->GetI2CBuffer()[8]) << 8) | I2CPERIPHERAL_inst1->GetI2CBuffer()[9];
		int16_t gy = (((int16_t)I2CPERIPHERAL_inst1->GetI2CBuffer()[10]) << 8) | I2CPERIPHERAL_inst1->GetI2CBuffer()[11];
		int16_t gz = (((int16_t)I2CPERIPHERAL_inst1->GetI2CBuffer()[12]) << 8) | I2CPERIPHERAL_inst1->GetI2CBuffer()[13];
		
		
//		I2CPERIPHERAL_inst1->ReadBytes(0x68, 14, nullptr);
		//mpu.getMotion6(&erx, &ery, &erz, &gx, &gy, &gz);
		HAL_Delay(1000);
	}
#endif //  0
	
//UserCode_Sectionbeforemain_end


static AEClock<AEObservorSensor, AEObservorInterpretorBaseDUMMY, 6, 0, 0, 0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0,0, 0, 0> clockForMpuL(500 );
clockForMpu = &clockForMpuL;

static mpuLoopAcquisition loopobjectForGettingMPUData_l;
loopobjectForGettingMPUData = &loopobjectForGettingMPUData_l;
loopobjectForGettingMPUData->InitObject(500, AEPriorities::HighestPriority);

static AEObservorSensorFilterOut< 1, Filter<GainFilter<FloatInTemplateWorkAround<-1196289, 9>>, 1>> sensorForAccelxL((int16_t*) sensorForAccelx_data, SensorResolution::Resolution16Bit  );
sensorForAccelx = &sensorForAccelxL;

static AEObservorSensorFilterOut< 1, Filter<GainFilter<FloatInTemplateWorkAround<-1196289, 9>>, 1>> sensorForAccelyL((int16_t*) sensorForAccely_data, SensorResolution::Resolution16Bit  );
sensorForAccely = &sensorForAccelyL;

static AEObservorSensorFilterOut< 1, Filter<GainFilter<FloatInTemplateWorkAround<1196289, 9>>, 1>> sensorForAccelzL((int16_t*) sensorForAccelz_data, SensorResolution::Resolution16Bit  );
sensorForAccelz = &sensorForAccelzL;

static AEObservorSensorFilterOut< 1, Filter<GainFilter<FloatInTemplateWorkAround<-17468220, 7>>, 1>> sensorForgyroxL((int16_t*) sensorForgyrox_data, SensorResolution::Resolution16Bit  );
sensorForgyrox = &sensorForgyroxL;

static AEObservorSensorFilterOut< 1, Filter<GainFilter<FloatInTemplateWorkAround<-17468220, 7>>, 1>> sensorForgyroyL((int16_t*) sensorForgyroy_data, SensorResolution::Resolution16Bit  );
sensorForgyroy = &sensorForgyroyL;

static AEObservorSensorFilterOut< 1, Filter<GainFilter<FloatInTemplateWorkAround<17468220, 7>>, 1>> sensorForgyrozL((int16_t*) sensorForgyroz_data, SensorResolution::Resolution16Bit  );
sensorForgyroz = &sensorForgyrozL;









//UserCode_Sectionbeforelinks
//UserCode_Sectionbeforelinks_end



//UserCode_Sectionbeforeclock
//UserCode_Sectionbeforeclock_end
clockForMpu->SetObservorToClock(sensorForAccelx, AEClock_PrescalerEnum::PRESCALER1);
clockForMpu->SetObservorToClock(sensorForAccely, AEClock_PrescalerEnum::PRESCALER1);
clockForMpu->SetObservorToClock(sensorForAccelz, AEClock_PrescalerEnum::PRESCALER1);
clockForMpu->SetObservorToClock(sensorForgyrox, AEClock_PrescalerEnum::PRESCALER1);
clockForMpu->SetObservorToClock(sensorForgyroy, AEClock_PrescalerEnum::PRESCALER1);
clockForMpu->SetObservorToClock(sensorForgyroz, AEClock_PrescalerEnum::PRESCALER1);


//AEITEST_END_TestsAfterTimer_mpu6050driver(5000);
//UserCode_Sectionb
	
	loopobjectForGettingMPUData->UserInitialize(I2CPERIPHERAL_inst1);
//UserCode_Sectionb_end

AEAO::ConfigureAndStart();
}


//UserCode_Sectionc
//UserCode_Sectionc_end





#endif